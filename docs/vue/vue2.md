# 1. Vue 的基本原理

## 1.1 基本原理

当一个 Vue 实例创建时，Vue 会遍历 data 中的属性，用 Object.defineProperty（v3 使用 proxy）将他们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而使它关联的组件得以更新。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2369052cf3e244d5ac21c9505da97259~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

## 1.2 Vue 的优点

### 1. 轻量级框架

只关注视图层，是一个构建数据的视图集合，大小只有几十 kb。

### 2. 简单易学

国人开发，中文文档，不存在语言障碍，易于理解和学习。

### 3. 双向数据绑定

保留了 angular 的特点，在数据操作方面更为简单。

### 4. 组件化

保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势。

### 5. 视图、数据，结构分离

使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作。

### 6. 虚拟 DOM

dom 操作是非常耗费性能的，不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式。

### 7. 运行速度更快

相比较于 react 而言，同样是操作虚拟 dom，就性能而言，vue 存在很大的优势。

# 2. Vue 响应式的原理

## 2.1 什么是数据劫持

利用 Object.defineProperty 劫持对象的访问器，在属性值发生变化时我们可以获取变化。

## 2.2 发布者模式 / 订阅者模式

在软件架构中，发布订阅是一种消息范式，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是将发布的消息分为不同的类别，无需了解哪些订阅者可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在。

不同于观察者和被观察者，**发布者和订阅者互相不知道对方的存在，发布者只需要把消息发送到订阅器里面，订阅者只管接受自己需要订阅的内容**。

## 2.3 响应式原理

Vue 响应式的原理就是采用**数据劫持**结合**发布者-订阅者模式**的方式，通过**Object.defineProperty()**来劫持各个属性的 setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：

**Observe**(被劫持的数据对象) **Compile**(vue 的编译器) **Watcher**(订阅者) **Dep**(用于收集 Watcher 订阅者)

### 1. 需要给 Observe 的数据对象及其所有嵌套的子孙对象进行递归遍历，都加上 setter 和 getter 这样的属性，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。

### 2. Compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。

### 3. Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是：

### 4.

# 3. 组件之间的通信

## 3.1 父子组件通信

### prop

### event

### style 和 class

父组件可以向子组件传递 style 和 class，他们会合并到子组件的根元素中。

### attribute

如果父组件传递了一些属性到子组件，但子组件并没有声明这些属性，则他们称之为 attribute，这些属性会直接附着在子组件的根元素上，不包括 style 和 class。

子组件可以通过 inheritAttrs：false 配置，禁止将 attribute 附着在子组件的根元素上，但不影响通过 $attrs 获取。

### native 修饰符

在注册事件时，父组件可以使用 native 修饰符，将事件注册到子组件的根元素上。

### $listeners

子组件可以通过 $listeners 获取父组件传递过来的所有事件处理函数，不含 .native 修饰器。

### v-model

### sync 修饰符

**用于解决多个数据的双向绑定。**和 v-model 的作用类似，用于双向绑定，不同点在于 v-model 只能针对一个数据进行双向绑定，而 sync 修饰符没有限制。

### `$parent` 和 `$children`

在组件内部，可以通过 `$parent` 和 `$children` 属性，分别得到当前组件的父组件和子组件实例。

### `$slots` 和 `$scopedSlots`

### ref

父组件可以通过 ref 获取到子组件的实例

## 3.2 跨组件通信

### Provide 和 Inject

示例

```js
// 父组件提供 foo
var Provider = {
  provide: {
    foo: "bar",
  },
};
// 子组件注入 foo
var Child = {
  inject: ["foo"],
  created() {
    console.log(this.foo); // => 'bar'
  },
};
```

### router

### vuex

适用于大型项目的数据仓库。

### store 模式

适用于中小型项目的数据仓库。

缺陷：无法跟踪数据的变化，多个地方修改同一个数据，会导致数据变化难以理解，为了解决而却优化这些问题，最终也会变成 vuex。

### eventbus

组件通知事件总线发生了某些事，事件总线通知其他监听该事件的所有组件运行某个函数。

# 4. 请你阐述一下对 vue 虚拟 dom 的理解

## 4.1 什么是虚拟 dom ?

虚拟 dom 本质上就是一个普通的 JS 对象，用于描述视图的界面结构。

在 vue 中，每个组件都有一个 render 函数，每个 render 函数都会返回一个虚拟 dom 树，这也就意味着每个组件都对应一棵虚拟 DOM 树。

## 4.2 为什么需要虚拟 dom？

在 vue 中，渲染视图会调用 render 函数，这种渲染不仅发生在组件创建时，同时发生在视图依赖的数据更新时。如果在渲染时，直接使用真实 DOM，由于真实 DOM 的创建、更新、插入等操作会带来大量的性能损耗，从而就会极大的降低渲染效率。

因此，vue 在渲染时，使用虚拟 dom 来替代真实 dom，主要为解决渲染效率的问题。

## 4.3 虚拟 dom 是如何转换为真实 dom 的？

在一个组件实例首次被渲染时，它先生成虚拟 dom 树，然后根据虚拟 dom 树创建真实 dom，并把真实 dom 挂载到页面中合适的位置，此时，每个虚拟 dom 便会对应一个真实的 dom。

如果一个组件受响应式数据变化的影响，需要重新渲染时，它任然会重新调用 render 函数，创建出一个新的虚拟 dom 树，用新树和旧树对比，通过对比，vue 会找到最小更新量，然后更新必要的虚拟 dom 节点，最后，这些更新过的虚拟节点，会去修改他们对应的真实 dom。

这样一来，就保证了对真实 dom 达到最小的改动。

## 4.4 模板和虚拟 dom 的关系

vue 框架中有一个 compile 模块，它主要负责将模板转换为 render 函数，而 render 函数调用后将得到虚拟 dom。

编译的过程分两步：

1. 将模板字符串转换为 AST
2. 将 AST 转换为 render 函数

如果使用传统的引入方式，则编译时间发生在组件第一次加载时，这称之为运行时编译。

如果是在 vue-cli 的默认配置下，编译发生在打包时，这称之为模板预编译。

编译是一个极其耗费性能的操作，预编译可以有效的提高运行时的性能，而且，由于运行的时候已不需要编译，vue-cli 在打包时会排除掉 vue 中的 compile 模块，以减少打包体积。

模板的存在，仅仅是为了开发人员更加方便的书写界面代码。

**vue 最终运行的时候，最终需要的是 render 函数，而不是模板，因此，模板中的各种语法，在虚拟 dom 中都是不存在的，他们都会变成虚拟 dom 的配置。**

# 5. 请阐述一下 v-model 的原理

v-model 既可以作用于表单元素，又可作用于自定义组件，无论是哪一种情况，它都是一个语法糖，最终会生成一个属性和一个事件。

* **当作用于表单元素时**，vue 会根据作用的表单元素类型而生成合适的属性和事件。例如，作用于普通文本框的时候，它会生成 value 属性和 Input 事件，而当其作用于单选框或多选框时，它会生成 checked 属性和 change 事件。

* **当其作用于自定义组件时，**默认情况下，他会生成一个 value 属性和 input 事件。

  开发者可以通过组件的 model 配置来改变生成的属性和事件。

  ```js
  const Comp = {
    model: {
      prop: "number",
      event: "change",
    },
  };
  ```

  
