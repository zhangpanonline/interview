# web前端性能优化
面试中我们也常常被问到性能优化的问题，如果胡乱穿插一些优化方案，面试官会感觉没有条理性，我们也回答的没有拿捏感，所有我们更应该有思路、有条理的叙述出一个前端性能优化相对完整的流程，思路也是从 `浏览器 -〉资源 -〉图片 -〉代码 -> webpack`层面来讲解
## 浏览器
1. 减少HTTP请求
   如Chrome浏览器最多同时允许对同一个域名建立6个TCP连接，不同的浏览器有所区别，减少http请求也就是减少[三次握手四次](../network/http.md#13-一个页面从输入url到页面加载显示完成这个过程中都发生了什么)挥手的时间。

2. 使用 HTTP2.0
   [http2.0的优势](../network/http.md#9-http11-和-http20-的区别)

3. 设置浏览器缓存策略
   [缓存介绍](../network/http.md#22-与缓存相关的http请求头有哪些)

4. 白屏时间做加载动画增强用户体验

## 资源
1. 静态资源cdn
   静态css/js/img等资源可以做cdn缓存，这样把资源同步到全国各地，用户就能更快访问到。
   把不常改变的库放到 index.html 中，通过 cdn 引入，例如element-ui，然后你打包就会发现 vendor 文件小了很多

2. 静态资源单独域名
   静态资源单独域名是一种常见的优化网站性能的方法。
   1. 它可以减轻服务器的负载压力，加快浏览器并发加载速度。
   2. 浏览器请求并发限制（同一域名包括二级域名，在同一时间支持的并发请求数量的限制），超过限制以后就会阻塞。
   3. 独立域名方便在代理服务层做动静分离，动静分离更有利于CDN
   4. 当浏览器向服务器请求一个静态资源时，会先发送同域名下的cookie，对于静态资源服务器则不会对cookie做处理而浪费带宽。

3. gzip压缩

   > 什么是Gzip?
   >
   > 当用户访问我们的web站点时，服务器就将我们的网页文件进行压缩，将压缩后的文件传输到客户端，对于纯文本文件我们可以至少压缩到原大小的40%，这样大大提高了传输效率，页面便可更快的加载出来。

   * Nginx服务端配置Gzip服务，会消耗对应的服务器内存

     对`nginx.conf`文件的`http`配置项进行配置

     ```bash
         # 开启或者关闭gzip模块(on|off)
         gzip on;
         # 允许压缩的页面最小字节数, 默认值是0，不管页面多大都压缩。建议设置成大于1k的字节数，小于1k可能会越压越大
         gzip_min_length 1k;
         # 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。例如 4 4k 代表以4k为单位，按照原始数据大小以4k为单位的4倍申请内存。
         gzip_buffers 4 16k;
         # 识别http的协议版本。由于早期的一些浏览器或者http客户端，可能不支持gzip自解压，用户就会看到乱码，所以做一些判断还是有必要的。
         #gzip_http_version 1.0;
         # gzip压缩比，1 压缩比最小处理速度最快，9 压缩比最大但处理最慢（传输快但比较消耗cpu）。
         gzip_comp_level 2;
         # 匹配MIME类型进行压缩，（无论是否指定）"text/html"类型总是会被压缩的。
         gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;
         # 和http头有关系，加个vary头，给代理服务器用的
         gzip_vary off;
         # 表示IE6及以下禁止压缩
         gzip_disable "MSIE [1-6]\.";
     ```

   * 客户端压缩Gzip

     应尽可能减少对服务端内存的使用，毕竟服务端的资源是十分宝贵的。使用webpack进行Gzip打包压缩，需要用到`compression-webpack-plugin`插件。

4. 做服务端渲染（SSR）
   现在主流框架的页面构建都是交给了客户端来渲染，那至少需要两次http请求之后，一次是html/css/js资源，一次是请求页面数据，才开始构建，这是导致白屏的关键点之一，所以做SSR页面的话，能够直接返回页面，减少了不少首屏渲染时间。
   如果首页真的有瓶颈，可以考虑用 node 单独做服务端渲染，而下面的子页面仍用 spa 单页的方式交互。
   这里不推荐直接用 nuxt.js 服务端渲染方案，因为这样一来增加了学习成本，二来服务端的维护成本也会上升，有时在本机测试没问题，在服务端跑就有问题，为了省心，还是最大限度用静态页面较好。

5. 将CSS放在文件头部，JS放在底部

## 图片
1. 字体图标代替图片图标
   一些通用的小图标，如箭头、叉，可以使用字体图标，减少请求，渲染更快

2. 精灵图
   一些带有企业特色的小图标，如淘宝购物车，笑脸娃娃，可以让UI将其放到一张图片上，然后使用css背景定位来显示，以此减少图片请求次数。

3. 图片懒加载

   为了首屏渲染更快，图片可设置一张加载图代替，当页面在可视区域内时，再替换为真正的图片，如果有首屏很大的高清图，可先渲染清晰度低的缩略图，在首页基本构建完成下一次事件渲染再去替换为高清图。

4. 图片预加载

   可以在window.onload之后请求一些其他地方需要的图片资源。

   比如我们有一个活动页使用了高清图，我们可以在它入口前的首页加载它，当我们进去页面时，浏览器就会从缓存里读取这张图片。

5. 使用webp格式的图片，比png格式小，但分辨率相比jpg格式接近。

6. 小于10k的图片可以打包为base64格式

   可以使用`webpack` `url-loader` 处理。

## 代码
1. 慎用全局变量
   1. 全局变量定义在全局执行上下文，是所有作用域的顶端，局部找不到就会一直网上找，影响性能。
   2. 全局执行上下文一直存在于上下文执行栈，直到程序退出，不利于GC回收。
   3. 命名污染。
2. 缓存全局变量
   将使用中无法避免的全局变量缓存到局部
3. 减少重绘回流
   * 回流：当元素的规模尺寸、布局、隐藏等改变的时候，render dom 需要重新构建，这就是回流
   * 重绘：元素只更新颜色等不影响布局的，就只会发生重绘

    所以尽量减少频繁操作dom，即使操作也尽量在低层级的DOM节点操作；
    也可以使用绝对定位是元素脱离文档流，这样即使发生重绘回流时，也不会影响页面其他元素；
    此外必须大量操作DOM时，可以使用`documentFragment`(文档碎片)，它就像标准的 document 一样，可以存储所有子孙节点，但它不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会对性能产生影响。

4. `documentFragment`文档碎片优化节点添加
5. 节流、防抖
   * 防抖：事件被触发n秒后再执行回调，如果在这n秒内事件又被触发，则重新计时。
   * 节流：在单位时间内，只能有一次触发事件的回调函数执行，被触发多次，也只生效一次。

6. 少用闭包、减少内存泄漏

7. vue 路由的懒加载
    import 或者 require 懒加载。你打包就会发现，多了很多 1.xxxxx.js；2.xxxxx.js 等等，而vendor.xxx.js 没了，剩下 app.js 和 manifest.js，而且 app.js 还很小，我这里是 100k 多一点。
8. vue 组件尽量不要全局引入



## webpack
1. 减少代码体积
2. 按需加载
3. 提取第三方库代码：SplitChunksPlugin 插件来进行公共模块抽取，利用浏览器缓存可以长期缓存这些无需频繁变动的公共代码
4. Tree Shaking：将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数 --optimize-minimize 来实现
5. 不生成 map 文件
   找到 config/index.js，修改为 productionSourceMap: false